<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html>
    <head>

        <!-- proper charset -->
        <meta charset="utf-8">
        <!-- Disable mobile scaling -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

        <title>Nicolas Mattia</title>

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link href="https://fonts.googleapis.com/css?family=Montserrat|Varela+Round" rel="stylesheet">
        <link rel="stylesheet" href="../css/font-awesome/css/font-awesome.min.css">
        <link rel="alternate" type="application/atom+xml" title="nmattia Atom feed" href="../atom.xml?type=blog" />
        <link rel="alternate" type="application/rss+xml" title="nmattia RSS feed" href="../rss.xml?type=blog" />


        <!-- favicon -->
        <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
        <link rel="manifest" href="../site.webmanifest">
        <link rel="mask-icon" href="../safari-pinned-tab.svg" color="#3b6484">
        <meta name="msapplication-TileColor" content="#3b6484">
        <meta name="theme-color" content="#3b6484">



    </head>

    <body>
        <div class="main">
            <div class="header">
                <div class="logo">
                    <a href="../" class="home">Nicolas Mattia</br></a>
                    <div class="links">
                        <a href="https://www.github.com/nmattia"><i class="fa fa-github"></i></a>
                        <a href="https://www.linkedin.com/in/nicolas-mattia/"><i class="fa fa-linkedin"></i></a>
                        <a href="mailto:nicolas@nmattia.com"><i class="fa fa-envelope-o"></i></a>
                    </div>
                </div>
                <div class="nav">
                    <ul>
                        <li><a href="../">home</a></li>
                        <li><a href="../blog.html">blog</a></li>
                        <li><a href="../about.html">about</a></li>
                    </ul>
                </div>
            </div>
            <div class="content">
                <h1 id="nix-a-reproducible-setup-for-linux-and-macos">Nix: A Reproducible Setup for Linux and macOS</h1>
<p>This post describes how I set up a reproducible development environment in a few seconds on any Linux distribution (and potentially macOS as well). This setup includes simple executables (curl, git) but also programs with custom configurations and dotfiles (<code>vim</code>, <code>tmux</code>). The Nix language is used to describe the system configuration, which you can find <a href="https://github.com/nmattia/homies">on github</a> and follow along.</p>
<hr />
<p>Developers have access to wonderful tools, which, when leveraged appropriately, allow them to build wonderful things in no time. Some of these tools, like vim and Emacs, can be customized to the point that working with them becomes a second nature, and some people will put a lot of effort into making sure that their setup is tailored for their workflows. This sometimes involves spending hours fighting with dependencies, plugins, language syntax highlighters… only to wake up the next day and realize that their daily update broke everything.</p>
<p>I’ve used <a href="https://www.gnu.org/software/stow/">GNU stow</a>. I’ve stored my dotfiles <a href="https://developer.atlassian.com/blog/2016/02/best-way-to-store-dotfiles-git-bare-repo/">in a Git repository</a>. I’ve written scripts to extract and load sets of packages with <code>aptitude</code>. It never worked reliably. Now I have a solution that actually works. I’m using a few text files that describe my entire setup, store them on GitHub, and don’t anymore fear upgrading my system, losing my laptop or spawning short-lived development instances. Let me show you how.</p>
<p><em>If you’ve never heard of Nix, worry not, the next section will present its main concepts. If you’ve used Nix before, feel free to <a href="#nixos">skip ahead</a>. The sections are mostly independent, pick any one that is most relevant to you:</em></p>
<ul>
<li><a href="#nix-and-nixos">Introduction to Nix and NixOS</a></li>
<li><a href="#package-management">Descriptive package management</a></li>
<li><a href="#packaging-up-the-dotfiles-tmux-and-vim">Packaging dotfiles</a></li>
<li><a href="#cowsay-the-nix-shell">The nix-shell</a></li>
</ul>
<h2 id="nix-and-nixos">Nix and NixOS</h2>
<p><a href="https://nixos.org/nix/">Nix</a> is a programming language with unconventional properties, which was developed mostly to work as a package manager. Today we are not going to focus much on the language itself, but on the package management model and how it fits in Unix systems. Check out Jim Fisher’s <a href="https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55">post</a> for a good introduction to the language itself. From now on I may use “Nix” interchangeably for both the language and the package manager.</p>
<p>Here’s a quote from the <a href="https://nixos.org/nix/manual/">Nix manual</a>:</p>
<blockquote>
<p>In Nix, packages are stored in unique locations in the Nix store (typically, /nix/store). For instance, a particular version of the Subversion package might be stored in a directory <code>/nix/store/dpmvp969yhdqs7lm2r1a3gng7pyq6vy4-subversion-1.1.3/</code>, while another version might be stored in <code>/nix/store/5mq2jcn36ldlmh93yj1n8s9c95pj7c5s-subversion-1.1.2</code>. The long strings prefixed to the directory names are cryptographic hashes of all inputs involved in building the package — sources, dependencies, compiler flags, and so on. So if two packages differ in any way, they end up in different locations in the file system, so they don’t interfere with each other.</p>
</blockquote>
<p>This captures the essence of Nix. All this package building is described through a set of Nix files (with a <code>.nix</code> extension). Nix does <em>not</em> actually have a package archive: all it has is a package repository <em>description</em>, <a href="https://github.com/NixOS/nixpkgs"><code>nixpkgs</code></a>, which is nothing but a bunch of Nix files! Nix downloads those files and prepares the packages on your machine. Most of it, however, was already built and cached, so after installing Nix you should be able to download any package from <code>nixpkgs</code>’ cache:</p>
<pre class="shell"><code>$ curl https://nixos.org/nix/install | sh # install Nix
$ . $HOME/.nix-profile/etc/profile.d/nix.sh # make sure it's loaded
$ nix-env -i blender # download Blender and all its dependencies
installing 'blender-2.79a'
these paths will be fetched (65.18 MiB download, 302.81 MiB unpacked):
  /nix/store/0ary8jr20s5x2h6k83r4c1i5bh4ildjk-soxr-0.1.2
  /nix/store/0ivvxa7gli2lhsxsscgvycbzsbjj5l8w-python3-3.5.5
  /nix/store/0my884iq9l5w27wnslr0npnw8bbdx8mb-speexdsp-1.2rc3
  /nix/store/0nl0wmi37b6f338f8v0j60cvwciv602h-openjpeg-1.5.2
  ...
$ blender # have some fun with Blender</code></pre>
<p>Check out the <a href="https://nixos.org/nix/manual/">Nix manual</a> and the <a href="https://nixos.org/nixos/nix-pills/">Nix Pills</a> for a deeper introduction.</p>
<h3 id="nixos">NixOS</h3>
<p>There actually is an entire operating system based on Nix: <a href="https://nixos.org/">NixOS</a>. Everything, from your packages to the services and users, is described with Nix. Using NixOS is a great solution if you can afford it. Using the Nix package manager alone is much more lightweight, as you can always piggy back on your distribution’s package manager if you <em>need</em> to, and you can always get rid of Nix entirely (including everything it’s ever installed) by wiping <code>/nix</code>. I, personally, only need a single user on my system, and no services besides the ones provided by Ubuntu by default, so the setup I describe below is perfect.</p>
<h2 id="package-management">Package management</h2>
<p>I’ll start by showing you how I curate the set of packages installed on my system at all times: my <a href="https://github.com/nmattia/homies">homies</a>. Let’s have a look at the main <code>homies</code> Nix file, <a href="https://github.com/nmattia/homies/blob/7a6c82aa7c7b41e915b79ff0de9f8e4c185c1622/default.nix"><code>default.nix</code></a>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># default.nix</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="bu">let</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="ex">pkgs</span> = import (import ./nixpkgs) <span class="dt">{}</span>;</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="ex">bashrc</span> = …<span class="kw">;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="fu">git</span> = …<span class="kw">;</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="ex">tmux</span> = …<span class="kw">;</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  <span class="ex">vim</span> = …<span class="kw">;</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="ex">homies</span> =</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    [</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">      <span class="co"># Customized packages</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">      <span class="ex">bashrc</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">      <span class="fu">git</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">      <span class="ex">tmux</span></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">      <span class="ex">vim</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17"></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">      <span class="co"># Sourced directly from Nixpkgs</span></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">      <span class="ex">pkgs.curl</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">      <span class="ex">pkgs.htop</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21">      <span class="ex">pkgs.nix</span></a>
<a class="sourceLine" id="cb2-22" data-line-number="22">      <span class="ex">pkgs.pass</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">      <span class="ex">pkgs.tree</span></a>
<a class="sourceLine" id="cb2-24" data-line-number="24">      <span class="ex">pkgs.xclip</span></a>
<a class="sourceLine" id="cb2-25" data-line-number="25">    ];</a>
<a class="sourceLine" id="cb2-26" data-line-number="26"></a>
<a class="sourceLine" id="cb2-27" data-line-number="27"><span class="kw">in</span> … <span class="ex">homies</span></a></code></pre></div>
<p>The <code>let … in …</code> is a typical functional programming construct: it defines some values after the <code>let</code> and brings them into scope after the <code>in</code>. A few values are defined:</p>
<ul>
<li><code>pkgs</code>: where we’ll draw our packages from – you don’t <em>have</em> to use <code>nixpkgs</code>!</li>
<li><code>bashrc</code>, <code>git</code>, <code>tmux</code>, <code>vim</code>: some packages I customized for my needs, we’ll get to what exactly that means in the next sections.</li>
<li><code>homies</code>: the list of packages that I want to be installed on my system.</li>
</ul>
<p>If you’ve never had any exposure to functional programming, the code above might look somewhat strange: that’s fine. You should nevertheless be able to tailor it to your needs by adding some packages sourced from <code>nixpkgs</code> (e.g. <code>pkgs.blender</code> or <code>pkgs.firefox</code>) to the <code>homies</code> list.</p>
<p>The following command removes all your (Nix-) installed packages and replaces them with the ones defined in <code>default.nix</code>:</p>
<pre class="shell"><code>$ nix-env -f default.nix -i --remove-all
building '/nix/store/g9v8mgzp0j4ndswdf4s04lkryw26qr0p-user-environment.drv'...
created 289 symlinks in user environment</code></pre>
<p>Let’s deconstruct what’s happening:</p>
<ul>
<li><code>nix-env</code>: this is the command that deals with installing packages on and removing packages from your system.</li>
<li><code>-f default.nix</code>: by default <code>nix-env</code> will look for packages in <code>nixpkgs</code>; by specifying <code>default.nix</code> we actually instruct it not to install the <em>whole</em> set of packages defined in <code>nixpkgs</code>…</li>
<li><code>-i</code>: “install”.</li>
<li><code>--remove-all</code>: instruct <code>nix-env</code> to remove all the packages previously installed.</li>
</ul>
<p>All the <code>homies</code> packages are now installed. There might be something bugging you:</p>
<ul>
<li>Aren’t all packages located at a <code>/nix/store/XXXXXXX-foo</code>-style path?</li>
<li>Wasn’t I lead to believe that wiping <code>/nix</code> would get rid of nix?</li>
<li>How can the packages be present on my <code>$PATH</code> then; did Nix just tinker with my <code>$PATH</code> !?</li>
</ul>
<p>Nix didn’t tinker with your <code>$PATH</code>, or at least not just now. During the installation of Nix itself, you might have been asked to add the following line to your <code>.bashrc</code>/<code>.profile</code>:</p>
<pre class="shell"><code>. $HOME/.nix-profile/etc/profile.d/nix.sh</code></pre>
<p>What this small shell script does is very simple (in its essence): it adds <code>$HOME/.nix-profile/bin/</code> to your <code>$PATH</code>. When you run <code>nix-env -i</code> (as we did above) Nix will build the packages in a temporary directory, store them in a <code>/nix/store/XXXXXXX-foo</code>-style location (a so-called entry in the Nix store), and create a symlink in <code>$HOME/.nix-profile/bin/</code> to the newly created entry in the Nix store. This is very powerful because Nix can perform atomic updates, without ever erasing packages: it only updates the symlinks if the whole build was successful. This enables very interesting operations, like rolling back to a previous “generation” (a generation is created on every successful <code>nix-env -i</code> call):</p>
<pre class="shell"><code>$ nix-env --list-generations
  ...
  40   2018-03-11 20:25:41
  41   2018-03-17 11:03:52
  42   2018-03-18 20:39:10   (current)
$ nix-env --rollback
switching from generation 42 to 41
$ nix-env --list-generations
  ...
  40   2018-03-11 20:25:41
  41   2018-03-17 11:03:52   (current)
  42   2018-03-18 20:39:10
$ nix-env --switch-generation 42
switching from generation 41 to 42</code></pre>
<p>(No, it’s not on purpose, I just happen to be at generation <em>42</em>…)</p>
<p>You might start to wonder how this is possible, since built packages take up space and that space is limited. You can run garbage collection runs whenever you feel like it, which you can read more about <a href="https://nixos.org/nixos/nix-pills/garbage-collector.html">here</a>.</p>
<p>You now know how to perform basic package installs from a <code>.nix</code> file. Congratulations! Next, let’s see how to manage dotfiles.</p>
<h2 id="packaging-up-the-dotfiles-tmux-and-vim">Packaging up the dotfiles: tmux and vim</h2>
<p>As mentioned above, part of the <code>homies</code> are sourced directly from <code>nixpkgs</code> (<code>curl</code>, <code>htop</code>, …) while others are <em>customized</em> (in particular <code>tmux</code> and <code>vim</code>). The reason is that I use the former ones directly, while the latter ones I want to use with a dotfile, like <code>.tmux.conf</code> and <code>.vimrc</code>. We’ll start with packaging your beloved <code>.tmux.conf</code> with Nix (you can find <code>vim</code> in the <a href="#vim">next section</a>).</p>
<p>My <code>homies</code> have a <a href="https://github.com/nmattia/homies/tree/7a6c82aa7c7b41e915b79ff0de9f8e4c185c1622/tmux">special directory dedicated to <code>tmux</code></a>, which you might think of as a “module” (although <a href="https://nixos.org/nixos/manual/index.html#sec-writing-modules">modules in Nix</a> are something else):</p>
<pre class="shell"><code>$ tree tmux/
tmux
├── default.nix
└── tmux.conf

0 directories, 2 files</code></pre>
<p>You might have expected <code>tmux.conf</code>, which is exactly what you expect it to be. Let’s look at <code>tmux/default.nix</code> instead!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co"># Tmux with ./tmux.conf baked in</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">{</span> <span class="ex">tmux</span>, writeText, symlinkJoin, makeWrapper <span class="kw">}</span>:</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ex">symlinkJoin</span> {</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="ex">name</span> = <span class="st">&quot;tmux&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="ex">buildInputs</span> = [makeWrapper]<span class="kw">;</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="ex">paths</span> = [ tmux ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="ex">postBuild</span> = <span class="st">''</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    <span class="ex">wrapProgram</span> <span class="st">&quot;</span><span class="va">$out</span><span class="st">/bin/tmux&quot;</span> \</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    --add-flags <span class="st">&quot;-f ${./tmux.conf}&quot;</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="st">''</span>;</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">}</a></code></pre></div>
<p>There are a few things going on, but we can ignore most of that. We will focus on the following part:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1">  … = <span class="st">''</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="ex">wrapProgram</span> <span class="st">&quot;</span><span class="va">$out</span><span class="st">/bin/tmux&quot;</span> \</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    --add-flags <span class="st">&quot;-f ${./tmux.conf}&quot;</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="st">''</span>;</a></code></pre></div>
<p>First, the double (single-)quotes <code>''</code>: that’s a string. What’s inside the string is mostly bash. What’s not bash is the <code>${./tmux.conf}</code> part: that’s a way of referencing Nix values inside a bash statement – and inside any string, actually. To Nix, this snippet is just a string, it will just happen to be run as a bash script at some point. So <code>${ foo }</code> interpolates the <em>Nix</em> value <code>./tmux.conf</code> to a string. The next question is: what kind of value is <code>./tmux.conf</code>?</p>
<p>Wanna have a guess?</p>
<p>Well, it looks like a path, doesn’t it. And as it turns out there is a file <a href="https://github.com/nmattia/homies/blob/7a6c82aa7c7b41e915b79ff0de9f8e4c185c1622/tmux/tmux.conf"><code>tmux.conf</code></a> in the directory. A Nix value that starts with <code>./</code> is Nix’ quick way of creating an entry in the Nix store: by interpolating it in the snippet above, Nix will replace <code>${ ./tmux.conf }</code> with a <code>/nix/store/XXXXXXX-foo</code>-style path. Sweet! The rest of the obscure incantation is just a way of telling Nix to wrap <code>tmux</code> (some <code>tmux</code> that was built by Nix and lives in <code>/nix/store</code>) and bake in the <code>-f</code> flag which specifies the location of the <code>.tmux.conf</code> file to use. You can convince yourself of it by squinting long enough at the actual <code>tmux</code> that’s located on my <code>$PATH</code>:</p>
<pre class="shell"><code>$ cat $(which tmux)
#! /nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash -e
exec -a &quot;$0&quot; \
    &quot;/nix/store/7wxr8q4jga59my8j283d2qb9vsxnhja6-tmux/bin/.tmux-wrapped&quot;    \
    #                                                       ^               \
    #                               some weird symlink name 」              \
    #                                                                       \
    #                           the tmux.conf file  ﹁                      \
    -f /nix/store/jrixfc4b897cxwr8wbqb90xqskrax0qh-tmux.conf &quot;${extraFlagsArray[@]}&quot; &quot;$@&quot;</code></pre>
<p>And just like that, your beloved <code>.tmux.conf</code> is baked in your <code>tmux</code>! Next, vim and <code>vimrc</code>!</p>
<h2 id="vim">vim</h2>
<p>Let’s now bundle <code>vim</code> with a <code>vimrc</code> and some plugins. Maybe you’ve had this experience:</p>
<ul>
<li>Plugin A needs python 2.7,</li>
<li>Plugin B needs python 3.0,</li>
<li>Plugin C needs python 2.8, which is a special flavor of python 2.7.8 that can only be compiled during full moon.</li>
</ul>
<p>You might expect the <code>vim</code> setup to be a bit more complex, mostly because of plugins, but in practice it is fairly easy. Because the <a href="https://github.com/NixOS/nixpkgs"><code>nixpkgs</code></a> are hosted on GitHub, anybody is free to submit a pull request, and a bit of infrastructure was merged in for <code>vim</code> plugin support.</p>
<p>The python version (<em>versionssss</em>) issue mentioned above is completely alleviated with Nix, because the plugins themselves can specify their system dependencies, and different versions of Python/what-have-you can happily cohabit with one another. Here’s my complete vim setup:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co"># vim/default.nix</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">{</span> <span class="ex">symlinkJoin</span>, makeWrapper, vim_configurable, vimUtils, vimPlugins, haskellPackages <span class="kw">}</span>:</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="bu">let</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="ex">pluginDictionaries</span> = with vimPlugins<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    [</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">      <span class="ex">ctrlp</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">      <span class="ex">fugitive</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">      <span class="ex">gitgutter</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">      <span class="ex">nerdcommenter</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">      <span class="ex">nerdtree</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">      <span class="ex">surround</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">      <span class="ex">syntastic</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14">      <span class="ex">tmux-navigator</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15">      <span class="ex">vim-airline</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16">      <span class="ex">vim-indent-guides</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17">      <span class="ex">vim-markdown</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18">      <span class="ex">vim-multiple-cursors</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19">      <span class="ex">vim-nix</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">      <span class="ex">vim-trailing-whitespace</span></a>
<a class="sourceLine" id="cb10-21" data-line-number="21">      <span class="ex">vimproc</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">      <span class="ex">youcompleteme</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23">    ];</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">  <span class="ex">customRC</span> = vimUtils.vimrcFile</a>
<a class="sourceLine" id="cb10-25" data-line-number="25">    <span class="kw">{</span> <span class="ex">customRC</span> = builtins.readFile ./vimrc<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-26" data-line-number="26">      <span class="ex">packages.mvc.start</span> = extraPackages<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-27" data-line-number="27">    <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb10-28" data-line-number="28"><span class="kw">in</span></a>
<a class="sourceLine" id="cb10-29" data-line-number="29"><span class="ex">symlinkJoin</span> {</a>
<a class="sourceLine" id="cb10-30" data-line-number="30">  <span class="ex">name</span> = <span class="st">&quot;vim&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31">  <span class="ex">buildInputs</span> = [makeWrapper]<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32">  <span class="ex">postBuild</span> = <span class="st">''</span></a>
<a class="sourceLine" id="cb10-33" data-line-number="33">    <span class="ex">wrapProgram</span> <span class="st">&quot;</span><span class="va">$out</span><span class="st">/bin/vim&quot;</span> \</a>
<a class="sourceLine" id="cb10-34" data-line-number="34">        --add-flags <span class="st">&quot;-u </span><span class="va">${customRC}</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb10-35" data-line-number="35">        --prefix PATH : <span class="va">${haskellPackages</span><span class="er">.hasktags</span><span class="va">}</span>/bin</a>
<a class="sourceLine" id="cb10-36" data-line-number="36">  <span class="st">''</span>;</a>
<a class="sourceLine" id="cb10-37" data-line-number="37">  <span class="ex">paths</span> = [ vim_configurable ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-38" data-line-number="38">}</a></code></pre></div>
<p>(and the <a href="https://github.com/nmattia/homies/blob/7a6c82aa7c7b41e915b79ff0de9f8e4c185c1622/vim/vimrc"><code>./vimrc</code></a> file:)</p>
<pre class="vim"><code>&quot; vim/vimrc

let mapleader=&quot;,&quot;
set encoding=utf-8

set nocompatible

&quot;allow backspacing over everything in insert mode
set backspace=indent,eol,start

…

&quot; Run hasktags on buffer write
:autocmd BufWritePost *.hs
    \ silent!
    \ !(hasktags --ignore-close-implementation --ctags .; sort tags)
    \ &amp;&gt; /dev/null

…</code></pre>
<p>The <code>vimrc</code> file itself is sourced from the file in my <a href="https://github.com/nmattia/homies">homies repository</a> (although in a different way than the <code>.tmux.conf</code> file from the previous section) and lists <em>zero</em> plugins. Those are magically handled by the <code>vimUtils.vimrcFile</code> function.</p>
<p>You might recognize the obscure <code>wrapProgram</code> incantation that we used with <code>tmux</code> earlier, which this time instructs <code>vim</code> to start with <code>-u …</code>. This is how we tell <code>vim</code> to use the Nix generated <code>vimrc</code>. But now, we pass a second argument to <code>wrapProgram</code>:</p>
<pre class="shell"><code>--prefix PATH : ${haskellPackages.hasktags}/bin</code></pre>
<p>The reason for that is that I trigger <code>hasktags</code> – a Haskell ctags generator – upon a Haskell file save, and <code>--prefix PATH …</code> will ensure that <code>hasktags</code> is in <code>$PATH</code> when <code>vim</code> is invoked. This used to be a pain to deal with, as I had to remember to also install the <code>hasktags</code> program after setting up my <code>dotfiles</code> on a new machine. Now the dependency is stored with my <code>homies</code>!</p>
<p><strong>Take home message</strong>: <code>vim</code> configuration does <strong>not</strong> have to be a pain. And you should <strong>not</strong> have to log in into your development boxes with a stripped down, unfamiliar default vim configuration. Bring your homies along. It’s so easy.</p>
<h2 id="cowsay-the-nix-shell">Cowsay: The nix-shell</h2>
<p>Alright, buckle up now, we’re getting real. I’ve talked about my so-called “homies” – the packages that I like having around – for a while now, and you might have wondered how I survive with those sad 10 packages (I counted). Here’s my answer: I don’t. Does that make sense? No? Then let me introduce the 8th Wonder of the World, the <code>nix-shell</code>:</p>
<pre class="shell"><code>$ cowsay the nix-shell
The program 'cowsay' is currently not installed. You can install it by typing:
sudo apt install cowsay
$ nix-shell -p cowsay
these paths will be fetched (0.01 MiB download, 0.03 MiB unpacked):
  /nix/store/w5v5l3799zn7cvrsqa3s307rqy7rrckn-cowsay-3.03+dfsg1-16
copying path '/nix/store/w5v5l3799zn7cvrsqa3s307rqy7rrckn-cowsay-3.03+dfsg1-16' from 'http://cache.nixos.org'...

[nix-shell]$ cowsay the nix-shell
 _______________
&lt; the nix-shell &gt;
 ---------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||

[nix-shell]$ exit
$ cowsay the nix-shell
The program 'cowsay' is currently not installed. You can install it by typing:
sudo apt install cowsay</code></pre>
<p>The <code>nix-shell</code> is the Nix equivalent of a one-night stand. It will bring packages in scope for the lifetime of a shell (this time not through symlinks: it crafts a special <code>$PATH</code> for the new shell). The simplest usage is the one showcased above – <code>nix-shell -p package1 -p package2 …</code> – which makes <code>package1</code>, <code>package2</code>, … available in your current shell session. After you’ve exited the shell, they’re gone.</p>
<p>The notion of a “package” in Nix is somewhat laxer than in, say, <code>aptitude</code>. Here’s a valid <code>nix-shell</code> invocation:</p>
<pre class="shell"><code>$ nix-shell -p &quot;python3.withPackages (ps: [ ps.numpy ps.tensorflow ])&quot;
these derivations will be built:
  /nix/store/sqy5nxzyy0z9vi01xxpyn6ycf8d4wc82-python3-3.6.4-env.drv
these paths will be fetched (42.11 MiB download, 295.94 MiB unpacked):
  /nix/store/4a2ggi5vl35x5saa2r12bk3hdkd7srx4-protobuf-3.4.1
  /nix/store/afq3xzvagjrivnv8fiz85z922yx0wd10-python3.6-tensorflow-1.5.0
  /nix/store/b8gd0cbvkm59x8flbc53bvsvmskyig5a-python3-3.6.4
  /nix/store/dnxxfd4jli8b4n3pci43m7rfaabzk9ra-python3.6-protobuf-3.4.1
  /nix/store/drp2q5jvbync5ad214ya1m3xmrc59anq-python3.6-numpy-1.14.1
  /nix/store/hd76py8m3223yyg6hc60ik920wagqcya-python3.6-setuptools-38.4.1
  /nix/store/jjp8wyg1vs70rryhz27ja5qacr6n29lf-python3.6-google-apputils-0.4.1
  /nix/store/m060ny27lay8iv16m524199l056ibvf6-python3.6-absl-py-0.1.10
  /nix/store/mf80jk2zzdsbgn70aisd0cs92x973m3y-python3.6-python-dateutil-2.6.1
  /nix/store/mn8f8vabp6d3sb9bs6cnf9gngc6v9mb2-python3.6-six-1.11.0
  /nix/store/vlqx79ni4ng0r3yzqz50g3fw9hahw4cr-python3.6-mox-0.5.3
  /nix/store/w0c63144k7f4rc8nzhlw7ajgz4pdgca9-python3.6-python-gflags-3.1.2
  /nix/store/xf6md6rjlnylzf1kgcvxn8kp1d13z35z-python3.6-pytz-2018.3
copying path '/nix/store/b8gd0cbvkm59x8flbc53bvsvmskyig5a-python3-3.6.4' from 'http://cache.nixos.org'...
…
copying path '/nix/store/afq3xzvagjrivnv8fiz85z922yx0wd10-python3.6-tensorflow-1.5.0' from 'http://cache.nixos.org'...
building '/nix/store/sqy5nxzyy0z9vi01xxpyn6ycf8d4wc82-python3-3.6.4-env.drv'...
created 278 symlinks in user environment

[nix-shell]$ python
Python 3.6.4 (default, Dec 19 2017, 05:36:13)
[GCC 7.3.0] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import tensorflow as tf
&gt;&gt;&gt; from tensorflow.examples.tutorials.mnist import input_data
&gt;&gt;&gt; …</code></pre>
<p>And that’s how you install Python and tensorflow. Sweet, heh?</p>
<p>Another way to use the <code>nix-shell</code> is to write a <code>shell.nix</code> file, which is evaluated when you call <code>nix-shell</code>. As it turns out, my homies are simply the packages that I regularly use <em>outside of code repositories</em> (by the way if you haven’t tried the <a href="https://github.com/nmattia/homies">homies</a>, the easiest way is to copy the repository and run <code>nix-shell</code> inside it). The <code>nix-shell</code> is amazing when working on code with others; just drop a <code>shell.nix</code> with <strong>all</strong> (and I mean <strong>all</strong>) the system dependencies for building and running the project in a <code>shell.nix</code>, and the rest of your team will thank you for it. For more info, check out <a href="http://zimbatm.com">zimbatm</a>’s talk on <a href="https://www.youtube.com/watch?v=ycjlpg296iI">Sneaking Nix at $work</a>.</p>
<p>This was a quick introduction to the <code>nix-shell</code>, or how to install packages for a very short lifetime or project-local scope. The concept is simple but the potential is huge. Go ahead and try it out!</p>
<p><strong>Pro-tip</strong>: Add the following to your <code>bashrc</code> for Haskell one-offs (or copy <a href="https://github.com/nmattia/homies/blob/7a6c82aa7c7b41e915b79ff0de9f8e4c185c1622/bashrc/bashrc">mine</a>):</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">ghc-shell()</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  <span class="ex">nix-shell</span> -p <span class="st">&quot;haskellPackages.ghcWithPackages (ps: with ps; [ </span><span class="va">$*</span><span class="st"> ])&quot;</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="kw">}</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="fu">ghci-with()</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  <span class="ex">nix-shell</span> \</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    -p <span class="st">&quot;haskellPackages.ghcWithPackages (ps: with ps; [ </span><span class="va">$*</span><span class="st"> ])&quot;</span> \</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    --run ghci</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="kw">}</span></a></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>That’s it for today. We went through the underlying concepts of the Nix package manager, learned how to package tools with customized configuration in a declarative and reproducible way and finally went through a few example use cases of the <code>nix-shell</code>. I’d like to thank <a href="http://zimbatm.com">zimbatm</a> and <a href="http://grahamc.com">Graham Christensen</a> for proofreading this text and suggesting improvements. Thanks, guys!</p>
<p><strong>P.S.</strong>: Nix is not an all-or-nothing package manager, you can install it today, write some configuration, wipe it entirely tomorrow and start where you left it next week – your configuration will still work. You might want to start by installing a few packages on your machine, or drop a <code>shell.nix</code> in a project that has a few system dependencies that are tricky to install; it’s up to you!</p>
            </div>
        </div>

        <script>
          if (document.location.hostname.search("nmattia.com") !== -1) {
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-82921132-1', 'auto');
            ga('send', 'pageview');
          }
        </script>
    </body>
</html>
