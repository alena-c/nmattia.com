<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html>
    <head>

        <!-- proper charset -->
        <meta charset="utf-8">
        <!-- Disable mobile scaling -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

        <title>Nicolas Mattia</title>

        <!-- Appended '?v=X' for dirtying cache -->
        <link rel="stylesheet" type="text/css" href="../css/default.css?v=1" />
        <link href="https://fonts.googleapis.com/css?family=Montserrat|Varela+Round" rel="stylesheet">
        <link rel="stylesheet" href="../css/font-awesome/css/font-awesome.min.css">
        <link rel="alternate" type="application/atom+xml" title="nmattia Atom feed" href="../atom.xml?type=blog" />
        <link rel="alternate" type="application/rss+xml" title="nmattia RSS feed" href="../rss.xml?type=blog" />
    </head>

    <body>
        <div class="main">
            <div class="header">
                <div class="logo">
                    <a href="../" class="home">Nicolas Mattia</br></a>
                    <div class="links">
                        <a href="https://www.github.com/nmattia"><i class="fa fa-github"></i></a>
                        <a href="https://www.linkedin.com/in/nicolas-mattia/"><i class="fa fa-linkedin"></i></a>
                        <a href="mailto:nicolas@nmattia.com"><i class="fa fa-envelope-o"></i></a>
                    </div>
                </div>
                <div class="nav">
                    <ul>
                        <li><a href="../">home</a></li>
                        <li><a href="../blog.html">blog</a></li>
                        <li><a href="../about.html">about</a></li>
                    </ul>
                </div>
            </div>
            <div class="content">
                <p><em>You can find this code on <a href="https://github.com/nmattia/2048-lens">Github</a> and follow along in <code>ghci</code>.</em></p>
<p>Last week a friend of mine asked me how I would implement the game <a href="https://gabrielecirulli.github.io/2048/">2048</a> in Java (at least the update logic) and we gave it a try. It went something like this:</p>
<ul>
<li><p>So we need to represent the grid. I guess <code>int[][]</code> will do. Is this going to be an array of rows, or an array of columns? Either way we’ll need to stick to it. <em>huh</em></p></li>
<li><p>Actually, it’ll be a sparse array, because not every cell will contain a value at all times. So an array of <code>Maybe int</code>. Oh right, <code>Integer</code>. We’ll need to remember to null-check. <em>huh</em></p></li>
<li><p>The easiest would be to define the function to update a row/column once, and then apply it to the grid in different directions. Extract a row/column, process it, and place it back. Keeping track of the indices. <em>huh</em></p></li>
</ul>
<p>It is actually a problem that can be solved elegantly in Haskell using a few <a href="http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Iso.html">Iso</a>s and <a href="http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Traversal.html">Traversal</a>s. We’ll use the <a href="http://hackage.haskell.org/package/linear">linear</a> library for representing the data and the <a href="http://hackage.haskell.org/package/lens">lens</a> library for accessing it.</p>
<h3 id="preparing-the-datatypes">Preparing the datatypes</h3>
<p>We’ll represent our board as a <span class="math inline">4 × 4</span> matrix from linear:</p>
<div style="text-align:center">
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Board</span> <span class="fu">=</span> <span class="dt">M44</span> (<span class="dt">Maybe</span> (<span class="dt">Sum</span> <span class="dt">Integer</span>))</a></code></pre></div>
</div>
<p>This is a simple, row-major matrix from linear. In order to make our life simpler we’ll define a function to display the board:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">λ<span class="fu">:</span> <span class="kw">let</span><span class="ot"> display ::</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (); display <span class="fu">=</span> Boxes.printBox <span class="fu">.</span> mkBox</a></code></pre></div>
<p>I made <code>Board</code> an instance of <code>Default</code>, so we can instantiate our first board as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">λ<span class="fu">:</span> <span class="kw">let</span> board <span class="fu">=</span><span class="ot"> def ::</span> <span class="dt">Board</span></a></code></pre></div>
<p>Let’s have a look:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">λ<span class="fu">:</span> display board</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span></a></code></pre></div>
<p>Alright, nothing too exciting yet. This is simply a board filled with <code>Nothing</code>s. We’ll use this to start discovering linear’s vector and matrix representation. A matrix of type <code>M44</code> is nothing but a vector of vectors, stored in row-major order; a vector of matrix rows:</p>
<div style="text-align:center">
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">type</span> <span class="dt">M44</span> a <span class="fu">=</span> <span class="dt">V4</span> (<span class="dt">V4</span> a)  <span class="co">-- Defined in ‘Linear.Matrix’</span></a></code></pre></div>
</div>
<p>The library has four very basic lenses for indexing into a vector: <code>_x</code>, <code>_y</code>, <code>_z</code> and <code>_w</code>. Let’s go to the <em>second row</em> (<code>_y</code>) of our board and set the <em>fourth element</em> (<code>_w</code>):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">λ<span class="fu">:</span> <span class="kw">import</span> <span class="dt">Control.Lens</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">λ<span class="fu">:</span> display <span class="fu">$</span> board <span class="fu">&amp;</span> _y <span class="fu">.</span> _w <span class="fu">.~</span> (<span class="dt">Just</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span>  <span class="dv">2</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span></a></code></pre></div>
<p>And it’s just that easy! Linear has a few other lenses for accessing elements and even vectors inside matrices. I definitely recommend checking it out.</p>
<h3 id="lines-of-logic">22 Lines of logic</h3>
<p>Let’s get back to our game. We first need an update function for the rows/columns. The game 2048 actually does not care about empty cells, wherever they are, it’ll just ignore them:</p>
<div style="text-align:center">
<pre><code>2 X 2 X             X X X 4
-------     ---&gt;    -------
X X 2 2             X X X 4</code></pre>
</div>
<p>In this small example the user swiped right, and even though the rows differed, the result was the same (it’s not injective). We’ll simply take a list containing the non-empty cells as an input, and output a list of the resulting non-empty cells. Here are a few examples:</p>
<pre><code>[2, 2]    -&gt; [4]
[1, 2, 2] -&gt; [1, 4]
[2, 1, 2] -&gt; [2, 1, 2]
[2, 2, 2] -&gt; [4, 2]</code></pre>
<p>We’ll specify some rules that might not correspond exactly to what the original game uses, but that will be good enough for us. When traversing a list:</p>
<div style="text-align:center">
<p><em>If two neighbors are equal, replace them by their sum.</em></p>
</div>
<p>The above is easily translated to Haskell code:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">merge ::</span> (<span class="dt">Eq</span> a, <span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">merge (x<span class="fu">:</span>x'<span class="fu">:</span>xs) <span class="fu">|</span> x <span class="fu">==</span> x' <span class="fu">=</span> (x <span class="fu">&lt;&gt;</span> x') <span class="fu">:</span> merge xs</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">merge (x<span class="fu">:</span>xs)              <span class="fu">=</span> x <span class="fu">:</span> merge xs</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">merge []                  <span class="fu">=</span> []</a></code></pre></div>
<p><em>Note that we’ve used a slightly more abstract version than <code>[Int] -&gt; [Int]</code>. This is useful for several reasons. For instance you might not have decided yet what type you are going to use to represent your cells (Int? Integer? An enumeration of the powers of two?). Also you might want to add a UI. In this case you will want to remember which cells were merged together so that you can play an animation. Below we will be using <code>Sum Integer</code>, the integers with addition as the monoidal composition (<code>&lt;&gt;</code>). </em></p>
<p>There’s not much room for error. GHC infers that we have covered all input cases, and we only need to make sure that the code reflects the rule above. We can open up <code>ghci</code> and verify with our (limited) test-suite:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">λ<span class="fu">:</span> merge [<span class="dv">2</span>, <span class="dv">2</span>]<span class="ot"> ::</span> [<span class="dt">Sum</span> <span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">[<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">λ<span class="fu">:</span> merge [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>]<span class="ot"> ::</span> [<span class="dt">Sum</span> <span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">[<span class="dv">1</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">λ<span class="fu">:</span> merge [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>]<span class="ot"> ::</span> [<span class="dt">Sum</span> <span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">[<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb10-9" data-line-number="9"></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">λ<span class="fu">:</span> merge [<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>]<span class="ot"> ::</span> [<span class="dt">Sum</span> <span class="dt">Integer</span>]</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">[<span class="dv">4</span>, <span class="dv">2</span>]</a></code></pre></div>
<p>Now we need to apply <code>merge</code> to different parts of the board. This is where the <a href="http://hackage.haskell.org/package/lens">lens</a> library comes in handy. More importantly <a href="http://hackage.haskell.org/package/linear">linear</a>’s good support for various types of lenses, particularly <code>Iso</code>s and <code>Traversal</code>s. Here’s my (instinctive) understanding of those:</p>
<ul>
<li>If you need to go back and forth between two datatypes <code>a</code> and <code>b</code>, you’ll need an <code>Iso' a b</code>.</li>
<li>If you need to get several <code>b</code>s from a datatype <code>a</code>, you’ll need a <code>Traversal' a b</code>.</li>
</ul>
<p>Earlier we prepared a <code>Board</code>. Now we have a function that operates on <code>[a]</code>. We’ll want to traverse our board to get lists. We’ll want a <code>Traversal' Board [a]</code>. Or rather several <code>Traversal' Board [a]</code>, one for each of the four orientations:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">rows, wors, cols,<span class="ot"> locs ::</span> <span class="dt">Traversal'</span> (<span class="dt">M44</span> (<span class="dt">Maybe</span>  a)) [a]</a></code></pre></div>
<p>The various directions are represented here:</p>
<p><img src="../images/rows-wors-cols-locs.jpg" style="width:512px;padding:15px" /></p>
<h3 id="setting-up-our-lenses">Setting up our lenses</h3>
<p>Let’s start with <code>rows</code>. Once again, the type <code>M44</code> is nothing but a vector of vectors, or a <code>V4</code> of <code>V4</code>s.</p>
<p><img src="../images/v4-v4-m44.jpg" style="width:512px;padding:15px" /></p>
<p>The vector type <code>V4</code> is an instance of <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Traversable.html">Traversable</a> (not <em>Traversal</em>, which is a type) so we can use <code>traverse</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">λ<span class="fu">:</span> <span class="fu">:</span>t traverse</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">traverse<span class="ot"> ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</a></code></pre></div>
<p>Simply put, <code>traverse</code> says</p>
<div style="text-align:center">
<p>If your <code>t</code> is <code>Traversable</code>, I’ll give you:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="dt">Traversal'</span> (t a) a</a></code></pre></div>
</div>
<p>Since <code>M44 a</code> is <code>V4 (V4 a))</code> it says:</p>
<div style="text-align:center">
<p>Your <code>V4</code> is <code>Traversable</code>, so I’ll give you:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="dt">Traversal'</span> (<span class="dt">M44</span> (<span class="dt">Maybe</span> a)) (<span class="dt">V4</span> (<span class="dt">Maybe</span> a))</a></code></pre></div>
</div>
<p>Good, so now we know how to get/set/act on each row of our board independently. Problem is that when traversing it, we are given the rows as <code>V4 (Maybe a)</code>s. But our function <code>merge</code> works on <code>[a]</code>s! Here come the Isos. We need an Iso that allows us to go back and forth between <code>V4 (Maybe a)</code> and <code>[a]</code>. The lens library comes with a handy function <code>iso</code> which builds an <code>Iso</code> from a pair of inverse functions. Here’s what we’ll use:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">list ::</span> <span class="dt">Iso'</span> (<span class="dt">V4</span> (<span class="dt">Maybe</span> a)) [a]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">list <span class="fu">=</span> iso toList fromList</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    toList v <span class="fu">=</span> reverse <span class="fu">$</span> catMaybes <span class="fu">$</span> foldl (flip (<span class="fu">:</span>)) [] v</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    fromList (<span class="ot">xs ::</span> [a]) <span class="fu">=</span> <span class="dt">V4</span> (xs<span class="fu">^?</span>ix <span class="dv">0</span>) (xs<span class="fu">^?</span>ix <span class="dv">1</span>) (xs<span class="fu">^?</span>ix <span class="dv">2</span>) (xs<span class="fu">^?</span>ix <span class="dv">3</span>)</a></code></pre></div>
<p>We have two operations here: <code>toList</code> and <code>fromList</code>. The first one simply copies all the <code>Just</code> values of a <code>V4</code> into a list, that is</p>
<div style="text-align:center">
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">toList ::</span> <span class="dt">V4</span> (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> [a]</a></code></pre></div>
</div>
<p>whereas, on the other hand, <code>fromList</code> recreates a vector from a list. Since there can be fewer than four values in a list, <code>fromList</code> adds as many <code>Just</code>s as possible to the <code>V4</code>, and fill the rest with <code>Nothing</code>s. You will notice that this also takes care of “shifting” the values to the beginning of the vector.</p>
<p>And, believe it or not, we’re almost done implementing our <code>rows</code> function. Here’s the last bit:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">rows <span class="fu">=</span> traverse <span class="fu">.</span> list</a></code></pre></div>
<p>We traverse our matrix one row at a time, but before handing the row to the caller, we transform it to a list using <code>toList</code>. And when we’re handed back a list, we insert it in the matrix as a row using <code>fromList</code>. Let’s see the result by setting all rows to <code>[1,2,3]</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">λ<span class="fu">:</span> display <span class="fu">$</span> board <span class="fu">&amp;</span> rows <span class="fu">.~</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="dv">1</span>  <span class="dv">2</span>  <span class="dv">3</span>  <span class="dt">X</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"></a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="dv">1</span>  <span class="dv">2</span>  <span class="dv">3</span>  <span class="dt">X</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="dv">1</span>  <span class="dv">2</span>  <span class="dv">3</span>  <span class="dt">X</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="dv">1</span>  <span class="dv">2</span>  <span class="dv">3</span>  <span class="dt">X</span></a></code></pre></div>
<h3 id="for-a-few-isos-more">For a few Isos more</h3>
<p>Now, let’s get started on <code>wors</code>, which should give us the reversed rows (when reading a row we start from the right-most element). The lens library has another handy abstraction: <a href="https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Iso.html#t:Reversing">Reversing</a>. Any type that is an instance of <code>Reversing</code> gets the <code>reversed</code> iso for free. Let’s make <code>V4</code> an instance of <code>Reversing</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Reversing</span> (<span class="dt">V4</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  reversing v <span class="fu">=</span> <span class="dt">V4</span> (v<span class="fu">^.</span>_w) (v<span class="fu">^.</span>_z) (v<span class="fu">^.</span>_y) (v<span class="fu">^.</span>_x)</a></code></pre></div>
<p>and <code>wors</code> can now be implemented:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">wors <span class="fu">=</span> traverse <span class="fu">.</span> reversed <span class="fu">.</span> list</a></code></pre></div>
<p>Facile, non? We get (vector) rows through <code>traverse</code>, reverse them, and <em>then</em> turn them into a list.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">λ<span class="fu">:</span> display <span class="fu">$</span> board <span class="fu">&amp;</span> wors <span class="fu">.~</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="dt">X</span>  <span class="dv">3</span>  <span class="dv">2</span>  <span class="dv">1</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3"></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="dt">X</span>  <span class="dv">3</span>  <span class="dv">2</span>  <span class="dv">1</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"><span class="dt">X</span>  <span class="dv">3</span>  <span class="dv">2</span>  <span class="dv">1</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"></a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="dt">X</span>  <span class="dv">3</span>  <span class="dv">2</span>  <span class="dv">1</span></a></code></pre></div>
<p>On to the next one: <code>cols</code>. Getting columns is easy: transpose the matrix. The columns of the original matrix are now the rows of the transposed matrix. Earlier we used the <code>iso</code> function to build an <code>Iso'</code> between <code>V4 (Maybe a)</code> and <code>[a]</code>. We’ll use it again to create an <code>Iso</code> between a matrix and its transposed self:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">transposed ::</span> <span class="dt">Iso'</span> (<span class="dt">M44</span> a) (<span class="dt">M44</span> a)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">transposed <span class="fu">=</span> iso transpose transpose</a></code></pre></div>
<p><em>(If you know of a function <code>f = join iso</code>, please ping me. I couldn’t find it.)</em></p>
<p>And now the two implementations for the columns and reversed columns:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">cols <span class="fu">=</span> transposed <span class="fu">.</span> rows</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">locs <span class="fu">=</span> transposed <span class="fu">.</span> wors</a></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">λ<span class="fu">:</span> display <span class="fu">$</span> board <span class="fu">&amp;</span> cols <span class="fu">.~</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="dv">1</span>  <span class="dv">1</span>  <span class="dv">1</span>  <span class="dv">1</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">          </a>
<a class="sourceLine" id="cb24-4" data-line-number="4"><span class="dv">2</span>  <span class="dv">2</span>  <span class="dv">2</span>  <span class="dv">2</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">          </a>
<a class="sourceLine" id="cb24-6" data-line-number="6"><span class="dv">3</span>  <span class="dv">3</span>  <span class="dv">3</span>  <span class="dv">3</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">          </a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">λ<span class="fu">:</span> display <span class="fu">$</span> board <span class="fu">&amp;</span> locs <span class="fu">.~</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb24-11" data-line-number="11"><span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span>  <span class="dt">X</span></a>
<a class="sourceLine" id="cb24-12" data-line-number="12">          </a>
<a class="sourceLine" id="cb24-13" data-line-number="13"><span class="dv">3</span>  <span class="dv">3</span>  <span class="dv">3</span>  <span class="dv">3</span></a>
<a class="sourceLine" id="cb24-14" data-line-number="14">          </a>
<a class="sourceLine" id="cb24-15" data-line-number="15"><span class="dv">2</span>  <span class="dv">2</span>  <span class="dv">2</span>  <span class="dv">2</span></a>
<a class="sourceLine" id="cb24-16" data-line-number="16">          </a>
<a class="sourceLine" id="cb24-17" data-line-number="17"><span class="dv">1</span>  <span class="dv">1</span>  <span class="dv">1</span>  <span class="dv">1</span></a></code></pre></div>
<h3 id="extra-lens-goodness">Extra lens goodness</h3>
<p>And that’s it, we’ve implemented the logic of the game! Believe it or not, it didn’t take us more than 22 lines of code. But make no mistake. Lenses aren’t for code golfing. They’re just well-crafted, type-safe abstractions. A lot of code was already written on top of those, meaning there’s a lot of stuff you can reuse. Also, when used properly, they should allow you to write less of your own code. I believe that (other things being equal) it is always better: less room for mistakes, less code to maintain, less code newcomers have to understand.</p>
<p>As opposed to the simplistic Java given in the introduction:</p>
<ul>
<li><p>We don’t care (too much) if a matrix is a vector of rows or a vector or columns (row-major or column-major). The Linear library abstracts this for us and gives us a few functions to use in order to traverse the matrix.</p></li>
<li><p>No null checks.</p></li>
<li><p>Thanks to lens, we haven’t used a single index explicitly. All the getting, updating and setting of values was declarative. Each indexing of an element has its own function: if an element is not there, the function is not there.</p></li>
</ul>
<p>Finally, we can wire everything together, making use this time of lens’ support for actions in the state monad:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Action</span> <span class="fu">=</span> <span class="dt">Up</span> <span class="fu">|</span> <span class="dt">Down</span> <span class="fu">|</span> <span class="dt">Left</span> <span class="fu">|</span> <span class="dt">Right</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"></a>
<a class="sourceLine" id="cb25-3" data-line-number="3"><span class="ot">play ::</span> (<span class="dt">MonadState</span> <span class="dt">Board</span> m) <span class="ot">=&gt;</span> <span class="dt">Action</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">play <span class="dt">Up</span>    <span class="fu">=</span> cols <span class="fu">%=</span> merge</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">play <span class="dt">Down</span>  <span class="fu">=</span> locs <span class="fu">%=</span> merge</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">play <span class="dt">Left</span>  <span class="fu">=</span> rows <span class="fu">%=</span> merge</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">play <span class="dt">Right</span> <span class="fu">=</span> wors <span class="fu">%=</span> merge</a></code></pre></div>
            </div>
        </div>

        <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-82921132-1', 'auto');
    ga('send', 'pageview');

        </script>
    </body>
</html>
