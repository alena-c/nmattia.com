<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html>
    <head>

        <!-- proper charset -->
        <meta charset="utf-8">
        <!-- Disable mobile scaling -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

        <title>Nicolas Mattia &ndash; Puzzle solving in Haskell </title>

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link href="https://fonts.googleapis.com/css?family=Montserrat|Varela+Round" rel="stylesheet">
        <link rel="stylesheet" href="../css/font-awesome/css/font-awesome.min.css">
        <link rel="alternate" type="application/atom+xml" title="nmattia Atom feed" href="../atom.xml?type=blog" />
        <link rel="alternate" type="application/rss+xml" title="nmattia RSS feed" href="../rss.xml?type=blog" />

        <!-- OG tags -->
        <meta property="og:title" content="Puzzle solving in Haskell" />
        <meta property="og:type" content="article" />
        <meta property="og:url" content="https://nmattia.com/posts/2016-07-31-bfs-tree.html" />
        

        <!-- favicon -->
        <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
        <link rel="manifest" href="../site.webmanifest">
        <link rel="mask-icon" href="../safari-pinned-tab.svg" color="#3b6484">
        <meta name="msapplication-TileColor" content="#3b6484">
        <meta name="theme-color" content="#3b6484">

    </head>

    <body>
        <div class="main">
            <div class="header">
                <div class="logo">
                    <a href="../" class="home">Nicolas Mattia</br></a>
                    <div class="links">
                        <a href="https://www.github.com/nmattia"><i class="fa fa-github"></i></a>
                        <a href="https://www.linkedin.com/in/nicolas-mattia/"><i class="fa fa-linkedin"></i></a>
                        <a href="mailto:nicolas@nmattia.com"><i class="fa fa-envelope-o"></i></a>
                    </div>
                </div>
                <div class="nav">
                    <ul>
                        <li><a href="../">home</a></li>
                        <li><a href="../blog.html">blog</a></li>
                        <li><a href="../about.html">about</a></li>
                    </ul>
                </div>
            </div>
            <div class="content">
                <p><em>This is a literate Haskell file. You can find this code on <a href="https://github.com/nmattia/nmattia.com/blob/master/posts/2016-07-31-bfs-tree.lhs">Github</a> and follow along in <code>ghci</code>.</em></p>
<p>In order to warm up for a round of interviews next week, I’ve been playing around with coding puzzles. Those are usually solved using imperative languages, and I thought I’d have a go at them using Haskell. I’ll share today’s experience, which hopefully will convince you that purely functional languages are (sometimes) suitable for puzzles.</p>
<p>====Disclaimer: <em>There is probably nothing new here. Also, there might be better solutions to solve the problem. I like this solution because it gave me an excuse to showcase Haskell’s laziness. Feel free to ping me if you come up with something better.</em></p>
<p>====The puzzle Let’s start with the problem itself. You are given a number, <span class="math inline"><em>x</em><sub>0</sub></span>, and a target, <span class="math inline"><em>x</em><sub><em>f</em></sub></span>. You are allowed two functions: <span class="math inline"><em>f</em>(<em>x</em>) = 2<em>x</em> + 1</span> and <span class="math inline"><em>g</em>(<em>x</em>) = 3<em>x</em> + 1 .</span></p>
<p>Give either the minimal number of applications of <span class="math inline"><em>f</em></span> and <span class="math inline"><em>g</em></span> that you need in order to reach <span class="math inline"><em>x</em><sub><em>f</em></sub></span> from <span class="math inline"><em>x</em><sub>0</sub></span>, or state that one cannot reach <span class="math inline"><em>x</em><sub><em>f</em></sub></span> from <span class="math inline"><em>x</em><sub>0</sub></span>.</p>
<p>For instance:</p>
<ul>
<li><p>in order to reach <span class="math inline"><em>x</em><sub><em>f</em></sub> = 4</span> from <span class="math inline"><em>x</em><sub>0</sub> = 1</span>, you need one application:</p>
<p><span class="math inline"><em>x</em><sub><em>f</em></sub> = 4 = 3 ⋅ 1 + 1 = <em>g</em>(1) = <em>g</em>(<em>x</em><sub>0</sub>)</span></p></li>
<li><p>in order to reach <span class="math inline"><em>x</em><sub><em>f</em></sub> = 10</span> from <span class="math inline"><em>x</em><sub>0</sub> = 1</span>, you need two applications:</p>
<p><span class="math inline"><em>x</em><sub><em>f</em></sub> = 10 = 3 ⋅ 3 + 1 = <em>g</em>(3) = <em>g</em>(2 ⋅ 1 + 1) = <em>g</em> ∘ <em>f</em>(1) = <em>g</em> ∘ <em>f</em>(<em>x</em><sub>0</sub>)</span></p></li>
<li><p>you cannot reach <span class="math inline"><em>x</em><sub><em>f</em></sub> = 8</span> from <span class="math inline"><em>x</em><sub>0</sub> = 1</span>.</p></li>
</ul>
<p>I like to think of the values as a tree where each node has degree <span class="math inline">2</span>. To get to a left child, apply <span class="math inline"><em>f</em></span>. To get to a right child, apply <span class="math inline"><em>g</em></span>. In this case the answer is equal to the depth of <span class="math inline"><em>x</em><sub><em>f</em></sub></span>, where the root is <span class="math inline"><em>x</em><sub>0</sub></span>. Now you just need to traverse the tree, starting from the root, until you find <span class="math inline"><em>x</em><sub><em>f</em></sub></span>. Using the following observation:</p>
<ul>
<li><span class="math inline">4 ⋅ <em>x</em> &gt; 3 ⋅ <em>x</em> + 1, ∀<em>x</em> &gt; 1</span></li>
</ul>
<p>we know that we can safely stop whenever we hit a node with depth <span class="math inline"><em>d</em> &gt; 4 ⋅ <em>x</em></span>.</p>
<p><img src="../images/topcoder-tree.jpg" style="width:512px;padding:15px" /></p>
<p>Clearly the number of nodes traversed (assuming a BFS) is proportional to the exponential of the depth (it is actually <span class="math inline">2<sup><em>d</em></sup></span>). But we also know that there is at least a factor <span class="math inline">2</span> between each “layer” (<span class="math inline">∀<em>x</em> &gt; 0, <em>f</em>(<em>x</em>) &gt; 2<em>x</em></span>). So we can conclude that <span class="math inline"><em>x</em><sub><em>f</em></sub> − <em>x</em><sub>0</sub> &gt; 2<sup><em>d</em></sup></span> and so our algorithm should run in <span class="math inline"><em>O</em>(<em>x</em><sub><em>f</em></sub> − <em>x</em><sub>0</sub>)</span>. Now let’s write some code.</p>
<p>====The code</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</a></code></pre></div>
<p>First we need to define a suitable tree structure. We define a binary tree in which each node holds some data. The data we will record is the node’s depth (or distance from the root) and a value:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">T</span> {<span class="ot"> depth  ::</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">              ,<span class="ot"> value  ::</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">              ,<span class="ot"> l      ::</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">              ,<span class="ot"> r      ::</span> <span class="dt">Tree</span> }</a></code></pre></div>
<p>We keep the links to the children lazy so that we can build an infinite tree. Whenever we create a node it is very likely that we will need the data it contains, so we keep the data strict. This is a typical lazy spine/strict leaves structure, and has the added bonus of easily allowing GHC to unpack the <code>Int</code>s.</p>
<p>Now, let’s build that tree:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">mkTree ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">mkTree <span class="fu">=</span> go <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    go d v <span class="fu">=</span> <span class="dt">T</span> { depth <span class="fu">=</span> d</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">               , value <span class="fu">=</span> v</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">               , l     <span class="fu">=</span> go (d <span class="fu">+</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="fu">*</span> v <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">               , r     <span class="fu">=</span> go (d <span class="fu">+</span> <span class="dv">1</span>) (<span class="dv">3</span> <span class="fu">*</span> v <span class="fu">+</span> <span class="dv">1</span>) }</a></code></pre></div>
<p>Note that we don’t have to limit ourselves to the functions <span class="math inline"><em>f</em></span> and <span class="math inline"><em>g</em></span>. Here’s, for instance, a complete binary tree:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- As an example</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">completeBinaryTree ::</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">completeBinaryTree <span class="fu">=</span> go <span class="dv">0</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    go d v <span class="fu">=</span> <span class="dt">T</span> { depth <span class="fu">=</span> d</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">               , value <span class="fu">=</span> v</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">               , l     <span class="fu">=</span> go (d <span class="fu">+</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="fu">*</span> v )</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">               , r     <span class="fu">=</span> go (d <span class="fu">+</span> <span class="dv">1</span>) (<span class="dv">2</span> <span class="fu">*</span> v <span class="fu">+</span> <span class="dv">1</span>) }</a></code></pre></div>
<p>This second tree would look like this:</p>
<p><img src="../images/complete-binary-tree.jpg" style="width:512px;padding:15px" /></p>
<p>Now comes the fun part, the breadth-first search (note that you typically don’t want to do a depth-first on an infinite tree). A typical implementation of a BFS uses a queue. It would go something like this:</p>
<ul>
<li>Dequeue a node from the queue and append it to an output list.</li>
<li>Enqueue all this node’s children.</li>
<li>Repeat until your queue is empty.</li>
</ul>
<p>This is a simplified version that will work just fine for a tree (we don’t need to check whether or not we have already visited the current node). If you know your functional data structures, you’ll recognize a typical queue:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Queue</span> a <span class="fu">=</span> <span class="dt">Queue</span> {<span class="ot"> front ::</span> [a]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">                     ,<span class="ot"> back  ::</span> [a] }</a></code></pre></div>
<p>Whenever you want to enqueue a value, you cons it on <code>back</code>. Whenever you want to dequeue a value, you uncons it from front. And whenever front is empty you replace it with back (in reverse order). This gives you worst-case <code>O(1)</code> for enqueue and dequeue operations, and <code>O(n)</code> for tail (that’s where you’ll reverse the back, see Okasaki’s <a href="https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf">Purely Functional Data Structures</a> for a good overview).</p>
<p>====The search</p>
<p>Easy enough. Now we just need a <code>State Queue</code> monad, traverse the tree, and update our queue every time, discarding the old one. Also, we’ll need a <code>Writer [Tree]</code> to output the nodes. Right? Well, in our case we can do much simpler. We will simply use a list and take advantage of the language’s laziness. We’ll take a list of nodes and return a list of their children. It will extract the left and right children of a node, then move to the next node, repeat the process and concat the result.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">children <span class="fu">=</span> concatMap (\t <span class="ot">-&gt;</span> [l t, r t]) nodes</a></code></pre></div>
<p>All good. Now we just need to bootstrap it:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> [<span class="dt">Tree</span>]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">bfs root <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    nodes <span class="fu">=</span> root <span class="fu">:</span> children</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    children <span class="fu">=</span> concatMap (\t <span class="ot">-&gt;</span> [l t, r t]) nodes</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="kw">in</span> nodes</a></code></pre></div>
<p>Let’s check it out on our binary tree in <code>ghci</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">λ<span class="fu">:</span> value <span class="fu">&lt;$&gt;</span> take <span class="dv">10</span> (bfs completeBinaryTree)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</a></code></pre></div>
<p>Sweet! When <code>concatMap</code> is called the first time, it’ll split the root into its left and right children. This means that the root’s left child is now the second element in <code>nodes</code>. When <code>concatMap</code> has to work again, it’ll spit out first the left child’s own children, then the right child’s own children, etc, concating the children lists every time. Looks like we have a breadth-first search using a list instead of a queue! And added bonus, we got rid of <code>Queue</code>’s <code>O(n)</code> worst case, since we never even <code>tail</code>!</p>
<p><img src="../images/queue-moving-window.jpg" style="width:512px;padding:15px" /></p>
<p>In this case, a queue is nothing more than a window, or slice, of a list. Every time we enqueue, we expand the window to the right. Every time we dequeue, we shrink the window on the left. This is unfortunately not an all purpose queue. Once the first cell of the list is created, all the remaining ones must be determined already.</p>
<p>The only thing left to do is to traverse the nodes produced by <code>bfs</code> until we hit either <span class="math inline"><em>x</em><sub><em>f</em></sub></span> or a number that we know is too large:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">distance ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">distance x0 xf <span class="fu">=</span> go nodes</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    nodes <span class="fu">=</span> bfs <span class="fu">$</span> mkTree x0</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    go (t<span class="fu">:</span>ts) <span class="fu">|</span> value t <span class="fu">==</span> xf     <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> depth t</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">              <span class="fu">|</span> value t <span class="fu">&gt;</span> <span class="dv">4</span> <span class="fu">*</span> xf  <span class="fu">=</span> <span class="dt">Nothing</span> <span class="co">-- from analysis</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">              <span class="fu">|</span> otherwise         <span class="fu">=</span> go ts</a></code></pre></div>
<p><em>Et voilà!</em> We can go a bit fancy and add a cli (that will happily crash on you on bad input):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  [x0, xf] <span class="ot">&lt;-</span> (read <span class="fu">&lt;$&gt;</span>) <span class="fu">&lt;$&gt;</span> getArgs</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  print <span class="fu">$</span> distance x0 xf</a></code></pre></div>
<p>Compiled with</p>
<pre><code>$ ghc --make -O2 -funbox-strict-fields bfs-tree.lhs</code></pre>
<p>the program runs to up to 10,000,000,000 under two seconds, which is not too bad. (Dell XPS 13, 2015)</p>
<pre><code>$ time posts/2016-07-31-bfs-tree 1 3000000000
Nothing
posts/2016-07-31-bfs-tree 1 3000000000  0.57s user 0.13s system 99% cpu 0.708 total

$time posts/2016-07-31-bfs-tree 1 6000000000
Nothing
posts/2016-07-31-bfs-tree 1 6000000000  1.04s user 0.19s system 99% cpu 1.230 total

$ time posts/2016-07-31-bfs-tree 1 10000000000
Nothing
posts/2016-07-31-bfs-tree 1 10000000000  1.49s user 0.62s system 99% cpu 2.111 total</code></pre>
<p>To get it to run on larger inputs, I suspect one would need to find a better algorithm. It would maybe even allow replacing <code>Int</code>s with <code>Integer</code>s. Once again, if you do find something, please get in touch : )</p>
            </div>
        </div>

        <script>
          if (document.location.hostname.search("nmattia.com") !== -1) {
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-82921132-1', 'auto');
            ga('send', 'pageview');
            ga('set', 'anonymizeIp', true);
          }
        </script>
    </body>
</html>
